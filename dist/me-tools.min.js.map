{"version":3,"sources":["variable.js","element.js","event.js","index.js"],"names":["root","factory","define","amd","exports","module","meTools","fn","variable","this","copyValues","vals","deep","copy","val","Array","isArray","i","push","window","document","key","mergeObjects","object1","object2","result","key1","option1","hasOwnProperty","option2","key2","isEmptyObject","object","element","getElementById","elementSpec","getId","prefix","id","getAttribute","date","Date","Math","ceil","valueOf","random","setAttribute","getAncestors","selector","container","single","argSelector","argContainer","argSingle","arguments","length","body","parents","parent","parentElement","matches","isParent","child","node","parentNode","addAttributeValues","attributeName","values","attributeVal","currentVals","split","value","indexOf","join","removeAttributeValues","keepEmptyAttribute","expStart","expEnd","replace","RegExp","removeAttribute","hasAttributeValue","match","getRadioGroup","radio","form","name","slice","call","querySelectorAll","fetchFocusables","orderByTabindex","focusables","byTabindex","ordered","focusable","tabindex","max","j","k","getFocusables","tabDirection","evalCandidate","candidate","offsetWidth","offsetHeight","doneRadios","radioGroup","focusableRadio","concat","checked","filtered","tabable","backwardTabable","focusInside","toFocus","containerTabindex","focus","fnVariable","require","event","registerEvent","scope","target","type","capture","registeredEvents","typeListeners","targetTypeHandlers","typeHandlers","tg","fns","addEventListener","unregisterEvent","fnDef","splice","removeEventListener","cTypeListeners","typeListener","shift","throttle","threshhold","trailing","last","deferTimer","now","args","clearTimeout","setTimeout","apply","debounce","pause","beginning","pauseTimer","fnElement","fnEvent","api"],"mappings":"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","file":"me-tools.min.js","sourcesContent":["(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('meTools.fn.variable', [\n    ], factory);\n  } else if(typeof exports === 'object') {\n    if (typeof module === 'object') {\n      module.exports = factory();\n    } else {\n      exports['meTools.fn.variable'] = factory();\n    }\n  } else {\n    root.meTools = root.meTools || {};\n    root.meTools.fn = root.meTools.fn || {};\n    root.meTools.fn.variable = factory();\n  }\n}(this, function () {\n\n  /*\n   ---------------\n   functions\n   ---------------\n   */\n\n  /**\n   * Create a copy of a variable.\n   *\n   * copyValues(vals [, deep])\n   *\n   * @param vals mixed\n   * @param deep bool; optional; deep-copy; default is true\n   * @returns {*} mixed; a copy of the passed value\n   */\n  function copyValues(vals, deep) {\n    deep = (typeof(deep) === 'undefined') || deep;\n\n    var copy,\n      val;\n    if (Array.isArray(vals)) {\n      copy = [];\n      for (var i in vals) {\n        val = vals[i];\n        copy.push((deep && typeof val === 'object') ?\n          copyValues(val)\n          : val);\n      }\n\n    } else if (vals && typeof(vals) === 'object' && typeof(vals.tagName) === 'undefined' && vals !== window && vals !== document) {\n      copy = {};\n      for (var key in vals) {\n        val = vals[key];\n        copy[key] = (deep && typeof val === 'object') ?\n          copyValues(val)\n          : val;\n      }\n\n    } else {\n      copy = vals;\n    }\n    return copy;\n  }\n\n  /**\n   * Merge 2 Objects and return a copy.\n   *\n   * mergeObjects(object1, object2)\n   *\n   * @param object1 Object\n   * @param object2 Object\n   * @returns {{}} New merged Object\n   */\n  function mergeObjects(object1, object2) {\n    object1 = object1 || {};\n    object2 = object2 || {};\n    var result = {};\n    for (var key1 in object1) {\n      var option1 = object1[key1];\n      if (object2.hasOwnProperty(key1)) {\n        var option2 = object2[key1];\n        if (Array.isArray(option2) || typeof(option2) !== 'object' || typeof(option1) !== 'object') {\n          result[key1] = copyValues(option2);\n        } else {\n          result[key1] = mergeObjects(option1, option2);\n        }\n      } else {\n        result[key1] = copyValues(option1);\n      }\n    }\n    for (var key2 in object2) {\n      if (!result.hasOwnProperty(key2)) {\n        result[key2] = copyValues(object2[key2]);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Check if an object is empty.\n   *\n   * isEmptyObject(object)\n   *\n   * @param object Object\n   * @returns {boolean}\n   */\n  function isEmptyObject(object) {\n    for (var i in object) {\n      return false;\n    }\n    return true;\n  }\n\n  /*\n   ---------------\n   api\n   ---------------\n   */\n\n  return {\n    copyValues: copyValues,\n    mergeObjects: mergeObjects,\n    isEmptyObject: isEmptyObject\n  };\n\n}));\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('meTools.fn.element', [\n    ], factory);\n  } else if(typeof exports === 'object') {\n    if (typeof module === 'object') {\n      module.exports = factory();\n    } else {\n      exports['meTools.fn.element'] = factory();\n    }\n  } else {\n    root.meTools = root.meTools || {};\n    root.meTools.fn = root.meTools.fn || {};\n    root.meTools.fn.element = factory();\n  }\n}(this, function () {\n\n  /*\n   ---------------\n   functions\n   ---------------\n   */\n\n  /**\n   * Get the specified element.\n   *\n   * getElementById(elementSpec)\n   *\n   * @param elementSpec mixed; string (id) or element;\n   * @returns {*} element or null\n   */\n  function getElementById(elementSpec) {\n    if (typeof(elementSpec) === 'object' && typeof(elementSpec.tagName) !== 'undefined') {\n      return elementSpec;\n\n    } else if (typeof(elementSpec) === 'string') {\n      return document.getElementById(elementSpec);\n\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the ID of an element. If the element has no ID, it will be assigned a random ID.\n   *\n   * getId(element [, prefix])\n   *\n   * @param element DOM element\n   * @param prefix string; optional; A prefix for generated IDs; default is 'id-'\n   * @returns {string} ID\n   */\n  function getId(element, prefix) {\n    var id = element.getAttribute('id');\n\n    if (!id) { // assign an ID\n      prefix = prefix || 'id-';\n      do {\n        var date = new Date();\n        id = prefix + Math.ceil(date.valueOf() % 10000 * Math.random());\n      } while (document.getElementById(id));\n\n      element.setAttribute('id', id);\n    }\n\n    return id;\n  }\n\n  /**\n   * Get all ancestors of an element, possibly matching a selector, up to an optional container.\n   *\n   * Note: this function uses matches(selector), so you need to include a polyfill for all IEs!\n   *\n   * getAncestors(element [, selector] [, container] [, single])\n   *\n   * @param element DOM-Element;\n   * @param selector String; optional; selector to match the parents against\n   * @param container DOM-Element; optional; max parent to check; default is body\n   * @param single Boolean; optional; return only the next matching ancestor\n   * @return mixed; array or false/element if single===true\n   */\n  function getAncestors(element, selector, container, single) {\n    // prepare arguments\n    var\n      argSelector = false,\n      argContainer = false,\n      argSingle = false;\n    for (var i = 1; i < arguments.length; i++) {\n      switch (typeof(arguments[i])) {\n        case 'string':\n          argSelector = arguments[i];\n          break;\n        case 'object':\n          argContainer = arguments[i];\n          break;\n        case 'boolean':\n          argSingle = arguments[i];\n          break;\n      }\n    }\n    selector = argSelector;\n    container = argContainer || document.body;\n    single = argSingle;\n\n    var parents = [],\n      getAncestors = function (element) {\n        var parent = element.parentElement;\n        if (!selector || parent.matches(selector)) {\n          if (single) {\n            return parent;\n          } else {\n            parents.push(parent);\n          }\n        }\n        if (parent === container) {\n          return single ? false : parents;\n        }\n        return getAncestors(parent);\n      }\n      ;\n    return getAncestors(element);\n  }\n\n  /**\n   * Check if an element is the parent of another element.\n   *\n   * isParent(parent, child)\n   *\n   * @param parent DOM-element\n   * @param child DOM-element\n   * @returns {boolean}\n   */\n  function isParent(parent, child) {\n    var node = child.parentNode;\n    while (node !== null) {\n      if (node === parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * Add 1 or more values to an attribute.\n   *\n   * addAttributeValues(element, attributeName, values)\n   *\n   * @param element DOM-element\n   * @param attributeName string\n   * @param values mixed; string or array of strings\n   */\n  function addAttributeValues(element, attributeName, values) {\n    values = Array.isArray(values) ? values : [values];\n\n    var\n      attributeVal = element.getAttribute(attributeName),\n      currentVals = attributeVal ? attributeVal.split(' ') : [];\n\n    for (var i = 0; i < values.length; i++) {\n      var value = values[i];\n      if (currentVals.indexOf(value) === -1) {\n        currentVals.push(value);\n      }\n    }\n    element.setAttribute(attributeName, currentVals.join(' '));\n  }\n\n  /**\n   * Remove one or more values from an attribute.\n   *\n   * removeAttributeValues(element, attributeName, values, keepEmptyAttribute)\n   *\n   * @param element DOM-element\n   * @param attributeName string\n   * @param values mixed; string or array of strings\n   * @param keepEmptyAttribute bool\n   */\n  function removeAttributeValues(element, attributeName, values, keepEmptyAttribute) {\n    var attributeVal = element.getAttribute(attributeName);\n    if (attributeVal) {\n      var\n        expStart = '((^| )',\n        expEnd = '(?= |$))';\n\n      attributeVal = attributeVal.replace(new RegExp(Array.isArray(values) ?\n        expStart + values.join(expEnd + '|' + expStart) + expEnd :\n        expStart + values + expEnd, 'g'),\n        '');\n\n      if (keepEmptyAttribute || attributeVal) {\n        element.setAttribute(attributeName, attributeVal);\n      } else {\n        element.removeAttribute(attributeName);\n      }\n    }\n  }\n\n  /**\n   * Checks if an attribute has a value (word).\n   *\n   * hasAttributeValue(element, attributeName, value)\n   *\n   * @param element DOM-element\n   * @param attributeName string\n   * @param value string\n   * @returns {boolean}\n   */\n  function hasAttributeValue(element, attributeName, value) {\n    var attributeVal = element.getAttribute(attributeName);\n    if (attributeVal) {\n      var\n        expStart = '((^| )',\n        expEnd = '(?= |$))';\n\n      return !!attributeVal.match(new RegExp(expStart + value + expEnd, 'g'));\n    }\n    return false;\n  }\n\n  /**\n   * Get all radio-buttons belonging to a radio-button's group\n   * @param radio DOM-Element radio element\n   * @returns []\n   */\n  function getRadioGroup(radio) {\n    // get the form for the radiobutton\n    var\n      form = getAncestors(radio, 'form', true) || // radiobutton is contained in a form\n        document,\n      name = radio.getAttribute('name');\n\n    return [].slice.call(form.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]'));\n  }\n\n\n  /**\n   * Returns all focusable elements, ordered by tabindex\n   * @param container DOM-Element; required\n   * @param selector String selector for elements which are focusable; optionsl; default is 'a,frame,iframe,input:not([type=hidden]),select,textarea,button,*[tabindex]'\n   * @returns {Array}\n   */\n  function fetchFocusables (container, selector) {\n    selector = selector || 'a,frame,iframe,input:not([type=hidden]),select,textarea,button,*[tabindex]:not([tabindex=\"-1\"])';\n    return orderByTabindex(container.querySelectorAll(selector));\n\n  }\n\n  /**\n   * @param focusables Array of Dom-Elements\n   * @returns {Array}\n   */\n  function orderByTabindex (focusables) {\n    var\n      byTabindex = [],\n      ordered = [];\n\n    for (var i = 0; i < focusables.length; i++) {\n      var\n        focusable = focusables[i],\n        tabindex = Math.max(0, focusable.getAttribute('tabindex') || 0);\n\n      byTabindex[tabindex] = byTabindex[tabindex] || [];\n      byTabindex[tabindex].push(focusable);\n    }\n\n    for (var j in byTabindex) {\n      for (var k in byTabindex[j]) {\n        ordered.push(byTabindex[j][k]);\n      }\n    }\n\n    return ordered;\n  }\n\n  /**\n   * Return not disabled, visible, tabable-radio ordered by the specified tab-direction\n   * @param focusables Array of DOM-Elements; required\n   * @param tabDirection int; optional; tab-direction (-1 or 1); default is 1\n   * @returns {Array} or false\n   */\n  function getFocusables (focusables, tabDirection) {\n    // prepare argument\n    tabDirection = typeof(tabDirection) === 'undefined' ? 1 : tabDirection;\n\n    var\n      filtered = [],\n      doneRadios = []; // already processed radio-buttons\n\n    function evalCandidate(candidate) {\n      if (candidate.matches(':not([disabled])') && (candidate.offsetWidth || candidate.offsetHeight)) { // not disabled & visible\n        if (candidate.matches('input[type=\"radio\"]')) { // remove all radio buttons which are not tabable\n          if (doneRadios.indexOf(candidate) === -1) { // group of this radio not processed yet\n            // get radio-group\n            var\n              radioGroup = getRadioGroup(candidate),\n              focusableRadio = null;\n\n            doneRadios = doneRadios.concat(radioGroup);\n\n            // get tabable radios of the group (checked or first&last of group)\n            for (var j = 0; j < radioGroup.length; j++) {\n              var radio = radioGroup[j];\n              if (radio.checked) {\n                focusableRadio = radio;\n                break;\n              }\n            }\n            if (!focusableRadio) {\n              focusableRadio = tabDirection === -1 ? radioGroup[radioGroup.length-1] : radioGroup[0]; // default is tabable in tab-direction!!!\n            }\n            return focusableRadio;\n          }\n\n        } else {\n          return candidate;\n        }\n\n        return false;\n      }\n    }\n\n    // remove all elements which are not tabable\n    if (tabDirection === 1) {\n      for (var i = 0; i < focusables.length; i++) {\n        var tabable = evalCandidate(focusables[i]);\n        if (tabable) {\n          filtered.push(tabable);\n        }\n      }\n    } else {\n      for (var j = focusables.length-1; j >= 0; j--) {\n        var backwardTabable = evalCandidate(focusables[j]);\n        if (backwardTabable) {\n          filtered.push(backwardTabable);\n        }\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   *\n   * @param container DOM-Element\n   * @param fn(container, focusables) Function returning the element to focus\n   */\n  function focusInside(container, fn) {\n    var\n      toFocus = null,\n      focusables = getFocusables(fetchFocusables(container));\n\n    if (typeof fn === 'function') {\n      toFocus = fn(container, focusables);\n    }\n    if (!toFocus && focusables.length) {\n      toFocus = focusables[0];\n    }\n    if (!toFocus) {\n      var containerTabindex = container.getAttribute('tabindex');\n      if (!containerTabindex) {\n        container.setAttribute('tabindex', '-1');\n      }\n      toFocus = container;\n    }\n\n    toFocus.focus();\n  }\n\n  /*\n   ---------------\n   api\n   ---------------\n   */\n\n  return {\n    getElementById: getElementById,\n    getId: getId,\n    getAncestors: getAncestors,\n    isParent: isParent,\n    addAttributeValues: addAttributeValues,\n    removeAttributeValues: removeAttributeValues,\n    hasAttributeValue: hasAttributeValue,\n    fetchFocusables: fetchFocusables,\n    orderByTabindex: orderByTabindex,\n    getFocusables: getFocusables,\n    focusInside: focusInside\n  };\n\n}));\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('meTools.fn.event', [\n      'meTools.fn.variable'\n    ], factory);\n  } else if(typeof exports === 'object') {\n    var fnVariable = require('./variable');\n    if (typeof module === 'object') {\n      module.exports = factory(fnVariable);\n    } else {\n      exports['meTools.fn.event'] = factory(fnVariable);\n    }\n  } else {\n    root.meTools = root.meTools || {};\n    root.meTools.fn = root.meTools.fn || {};\n    root.meTools.fn.event = factory(root.meTools.fn.variable);\n  }\n}(this, function (fnVariable) {\n\n  /*\n   ---------------\n   functions\n   ---------------\n   */\n\n  /**\n   * Add an event-listener and register it to an instance.\n   * The instance will get a property 'registeredEvents' storing the registered events.\n   *\n   * registerEvent(scope, target, type, fn [, capture])\n   *\n   * @param scope object; instance to register the event to\n   * @param target DOM object; event target\n   * @param type string; event name\n   * @param fn function; event handler\n   * @param capture boolean; optional; capture the event; default is false\n   */\n  function registerEvent(scope, target, type, fn, capture) {\n\n    capture = capture || false;\n\n    var\n      registeredEvents = scope.registeredEvents = scope.registeredEvents || {},\n      typeListeners = registeredEvents[type] = registeredEvents[type] || [],\n      targetTypeHandlers = false\n      ;\n\n    for (var i in typeListeners) {\n      var typeHandlers = typeListeners[i];\n      if (typeHandlers.tg === target) {\n        targetTypeHandlers = typeHandlers;\n        break;\n      }\n    }\n\n    if (!targetTypeHandlers) {\n      targetTypeHandlers = {\n        tg: target,\n        fns: []\n      };\n      typeListeners.push(targetTypeHandlers);\n    }\n\n    targetTypeHandlers.fns.push([fn, capture]);\n\n    target.addEventListener(type, fn, capture);\n\n  }\n\n  /**\n   * Remove (an) event-listener(s), previously registered to an instance.\n   *\n   * unregisterEvent(scope [, target] [, type] [, fn] [, capture])\n   *\n   * @param scope object; instance the event was registered to\n   * @param target DOM object; optional; event target; if not set, matching events will be removed on all targets\n   * @param type string; optional; event name; if not set, all event-types will be removed\n   * @param fn function; optional; event handler; if not set, all event-handlers will be removed\n   * @param capture boolean; optional; if not set, captured & not-captured events are removed, if true only captured events are removed, if false only not-captured events are removed\n   */\n  function unregisterEvent(scope, target, type, fn, capture) {\n    if (!scope.registeredEvents) {\n      return;\n    }\n    var registeredEvents = scope.registeredEvents;\n\n    if (!type) {\n      for (type in registeredEvents) {\n        unregisterEvent(scope, target, type, fn, capture);\n      }\n      return;\n    }\n\n    if (!registeredEvents.hasOwnProperty(type)) {\n      return;\n    }\n    var typeListeners = registeredEvents[type];\n\n    if (!target) {\n      var cTypeListeners = fnVariable.copyValues(typeListeners);\n      while (cTypeListeners.length) {\n        var typeListener = cTypeListeners.shift();\n        unregisterEvent(scope, typeListener.tg, type, fn, capture);\n      }\n      return;\n    }\n\n    var fns = false,\n      typeHandlers;\n    for (var j in typeListeners) {\n      typeHandlers = typeListeners[j];\n      if (typeHandlers.tg === target) {\n        fns = typeHandlers.fns;\n        break;\n      }\n    }\n    if (!fns) {\n      return;\n    }\n\n    for (var k = 0; k < fns.length; k++) {\n      var fnDef = fns[k];\n      if ((typeof(fn) === 'undefined' || !fn || fn === fnDef[0]) &&\n        (typeof(capture) === 'undefined' || capture === fnDef[1])) {\n        fns.splice(k, 1);\n        target.removeEventListener(type, fnDef[0], fnDef[1]);\n        k--;\n      }\n    }\n\n    // remove unused info\n    if (!fns.length) {\n      typeListeners.splice(j, 1);\n    }\n    if (!typeListeners.length) {\n      delete registeredEvents[type];\n    }\n\n  }\n\n  /**\n   * Rate-limit the execution of a function (e.g. for events like resize and scroll).\n   * Returns a new function, that when called repetitively, executes the original function no more than once every delay milliseconds.\n   * (based on https://remysharp.com/2010/07/21/throttling-function-calls)\n   *\n   * throttle(fn [, threshhold] [, trailing] [, scope])\n   *\n   * @param fn function; original function to call\n   * @param threshhold int; optional; delay (ms) - execute fn no more than once every delay milliseconds; default is 250\n   * @param trailing boolean; optional; execute fn after the calls stopped; default is true\n   * @param scope object; optional; instance the function should be applied to\n   * @returns {Function}\n   */\n  function throttle(fn, threshhold, trailing, scope) {\n    // prepare arguments\n    threshhold = threshhold || 250;\n    trailing = typeof(trailing) === 'undefined' ? true:trailing;\n    scope = scope || this;\n\n    var\n      last,\n      deferTimer = null;\n\n    return function () {\n      var\n        now = +new Date(),\n        args = arguments;\n\n      if (last && now < last + threshhold) {\n        if (trailing) {\n          // hold on to it\n          clearTimeout(deferTimer);\n          deferTimer = setTimeout(function () {\n            last = now;\n            fn.apply(scope, args);\n          }, threshhold);\n        }\n\n      } else {\n        last = now;\n        clearTimeout(deferTimer);\n        fn.apply(scope, args);\n      }\n    };\n  }\n\n  /**\n   * Coalesce multiple sequential calls into a single execution at either the beginning or end (e.g. for events like keydown).\n   * Returns a new function, that when called repetitively, executes the original function just once per “bunch” of calls.\n   *\n   * debounce(fn [, pause] [, beginning] [, scope])\n   *\n   * @param fn function; original function to call\n   * @param pause int; optional; min pause (ms) between bunches of calls; default is 250\n   * @param beginning boolean; execute at the beginning of the call-bunch; default is false\n   * @param scope object; optional; instance the function should be applied to\n   * @returns {Function}\n   */\n  function debounce(fn, pause, beginning, scope) {\n    // prepare arguments\n    pause = pause || 250;\n    scope = scope || this;\n\n    var\n      last,\n      pauseTimer = null;\n\n    return function () {\n      var\n        now = +new Date(),\n        args = arguments;\n\n      if (!beginning) {\n        // defer a possible function call\n        clearTimeout(pauseTimer);\n        pauseTimer = setTimeout(function () {\n          fn.apply(scope, args);\n        }, pause);\n\n      } else if (!last || now > last + pause) {\n        fn.apply(scope, args);\n      }\n\n      last = now;\n    };\n  }\n\n  /*\n   ---------------\n   api\n   ---------------\n   */\n\n  return {\n    registerEvent: registerEvent,\n    unregisterEvent: unregisterEvent,\n    throttle: throttle,\n    debounce: debounce\n  };\n\n}));\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([\n      'meTools.fn.variable',\n      'meTools.fn.element',\n      'meTools.fn.event'\n    ], factory);\n  } else if(typeof exports === 'object') {\n    var\n      fnVariable = require('./fn/variable'),\n      fnElement = require('./fn/element'),\n      fnEvent = require('./fn/event');\n    if (typeof module === 'object') {\n      module.exports = factory(fnVariable, fnElement, fnEvent);\n    } else {\n      exports.meTools = factory(fnVariable, fnElement, fnEvent);\n    }\n  } else {\n    var meTools = root.meTools;\n    root.meTools = factory(meTools.fn.variable, meTools.fn.element, meTools.fn.event);\n    for (var i in meTools) {\n      root.meTools[i] = meTools[i];\n    }\n  }\n}(this, function (fnVariable, fnElement, fnEvent) {\n  var api = {};\n  for (var i in arguments) {\n    for (var j in arguments[i]) {\n      api[j] = arguments[i][j];\n    }\n  }\n\n  return api;\n\n}));\n\n"]}
/**
 * @license me-tools 3.0.0 Copyright (c) Mandana Eibegger <scripts@schoener.at>
 * Available via the MIT license.
 * see: https://github.com/meibegger/me-tools for details
 */
